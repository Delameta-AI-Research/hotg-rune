use legion::{Query, systems::CommandBuffer, world::SubWorld};
use proc_macro2::{Ident, Literal, Span, TokenStream};
use quote::quote;
use crate::codegen::{CustomSection, File};

#[legion::system]
pub(crate) fn run(
    cmd: &mut CommandBuffer,
    world: &SubWorld,
    sections: &mut Query<&CustomSection>,
) {
    let lib_rs = generate_lib_rs(sections.iter(world));
    let file = File::new("lib.rs", lib_rs.to_string().into_bytes());

    cmd.push((file,));
}

fn generate_lib_rs<'world>(
    sections: impl Iterator<Item = &'world CustomSection>,
) -> TokenStream {
    let prelude = generate_prelude();
    let custom_sections = generate_custom_sections(sections);
    let resources_module = generate_resources_module();
    let models_module = generate_models_module();
    let manifest = generate_manifest_function();
    let call = generate_call_function();

    quote! {
        #prelude
        #custom_sections
        #resources_module
        #models_module
        #manifest
        #call
    }
}

/// The `manifest()` function where we initialize our pipeline.
fn generate_manifest_function() -> TokenStream {
    quote! {
        #[no_mangle]
        pub extern "C" fn manifest() {}
    }
}

/// Imports and miscellaneous attributes added to the top of the file.
fn generate_prelude() -> TokenStream {
    quote! {
        //! Automatically generated by Rune. DO NOT EDIT!

        #![no_std]
        #![feature(alloc_error_handler)]
        #![allow(warnings)]

        extern crate alloc;

        #[macro_use]
        extern crate lazy_static;

        use alloc::boxed::Box;
        use hotg_rune_core::*;
        use hotg_rune_proc_blocks::*;

        static mut PIPELINE: Option<Box<dyn FnMut()>> = None;
    }
}

/// The `call()` function - a simple function which invokes the `PIPELINE`
/// constructed by [`generate_manifest_function()`].
fn generate_call_function() -> TokenStream {
    quote! {
        #[no_mangle]
        pub extern "C" fn _call(
            _capability_type: i32,
            _input_type: i32,
            _capability_idx: i32,
        ) -> i32 {
            unsafe {
                let pipeline = PIPELINE.as_mut()
                    .expect("The rune hasn't been initialized");
                pipeline();

                0
            }
        }
    }
}

/// Generate WebAssembly custom sections which are used to embed metadata in
/// the compiled Rune.
fn generate_custom_sections<'world>(
    sections: impl Iterator<Item = &'world CustomSection>,
) -> TokenStream {
    let sections = sections.map(generate_custom_section);

    quote! {
        /// Custom sections embedded in the Rune that can be inspected later.
        ///
        /// # Note
        ///
        /// These sections need to be at the top level to make sure the linker
        /// won't remove them during its "gc sections" pass, but we also don't
        /// want to pollute the top-level namespace so we put it inside an
        /// unnamed constant.
        const _: () = {
            #( #sections )*
        };
    }
}

fn generate_custom_section(s: &CustomSection) -> TokenStream {
    let ident = Ident::new(s.identifier(), Span::call_site());
    let section_name = &s.section_name;
    let data = Literal::byte_string(&s.value);
    let len = s.value.len();

    quote! {
        #[link_section = #section_name]
        static #ident: [u8; #len] = *#data;
    }
}

fn generate_resources_module() -> TokenStream {
    quote! {
        /// Lazily loaded accessors for all resources used by this Rune.
        mod resources {}
    }
}

fn generate_models_module() -> TokenStream {
    quote! {
        mod models {}
    }
}

#[cfg(test)]
mod tests {
    use std::{
        io::{Write, Read},
        process::{Command, Stdio},
    };
    use super::*;

    fn rustfmt(tokens: TokenStream) -> String {
        let mut child = Command::new("rustfmt")
            .stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .spawn()
            .unwrap();

        // Note: We need to wrap the fragment in a function so it'll parse
        let mut stdin = child.stdin.take().unwrap();
        writeln!(stdin, "fn main() {{").unwrap();
        writeln!(stdin, "{}", tokens).unwrap();
        writeln!(stdin, "}}").unwrap();
        stdin.flush().unwrap();
        drop(stdin);

        let mut stdout = child.stdout.take().unwrap();
        let mut pretty = String::new();
        stdout.read_to_string(&mut pretty).unwrap();

        let opening_curly = pretty.find("{").unwrap();
        let closing_curly = pretty.rfind("}").unwrap();

        pretty[opening_curly + 1..closing_curly].trim().to_string()
    }

    macro_rules! assert_quote_eq {
        ($left:expr, $right:expr) => {{
            let left = $left.to_string();
            let right = $right.to_string();

            if left != right {
                let pretty_left = rustfmt($left);
                let pretty_right = rustfmt($right);
                assert_eq!(pretty_left, pretty_right);
                assert_eq!(left, right);
            }
        }};
    }

    #[test]
    fn custom_section() {
        let section = CustomSection::new(".name", b"hello world".as_ref());
        let should_be = quote! {
            #[link_section = ".name"]
            static name: [u8; 11usize] = *b"hello world";
        };

        let got = generate_custom_section(&section);

        assert_quote_eq!(got, should_be);
    }
}
