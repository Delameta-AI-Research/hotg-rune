import { Capabilities, CapabilityType, Outputs, Shape } from ".";
import { Capability, Imports, Model, Output, Runtime, StructuredLogMessage } from "./Runtime";
import Tensor from "./Tensor";

type ModelConstructor = (model: ArrayBuffer) => Promise<Model>;
type Logger = (message: string | StructuredLogMessage) => void;

export type InputDescription = {
    type: CapabilityType,
    args: Partial<Record<string, number>>,
};

/**
 * A function that returns the desired input, either as a tensor or the raw
 * byte buffer.
 */
export type ReadInput = (input: InputDescription) => Tensor;

/**
 * A function which can be used to evaluate a Rune.
 */
export type Evaluate = (r: ReadInput) => Result;

/**
 * A builder object which can be used to initialize the Rune runtime.
 */
export class Builder {
    private modelHandlers: Partial<Record<string, ModelConstructor>> = {};
    private log: Logger = () => { };

    /**
     * Set a handler that will be called every time the Rune logs a message.
     */
    public onDebug(handler: Logger): this {
        this.log = handler;
        return this;
    }

    /**
     * Add support for a new type of model.
     * @param mimetype The "mimetype" that specifies which type of model being
     * handled.
     * @param constructor A constructor which will load the model.
     * @returns
     */
    public withModelHandler(mimetype: string, constructor: ModelConstructor): this {
        this.modelHandlers[mimetype] = constructor;

        return this;
    }

    public async build(rune: ArrayBuffer | string): Promise<Evaluate> {
        if (typeof rune == "string") {
            const response = await fetch(rune);
            rune = await response.arrayBuffer();
        }
        const { modelHandlers, log } = this;

        const imports = new ImportsObject(modelHandlers, log);
        let runtime: Runtime | undefined = await Runtime.load(rune, imports);

        return readInputs => {
            if (!runtime) {
                throw new Error("A previous call to this Rune has failed, leaving it in an invalid state");
            }

            imports.setInputs(readInputs);

            try {
                runtime.call();
            } catch (e) {
                // We encountered an error while invoking the Rune, typically by
                // throwing an exception from one of our host functions.  JS
                // exceptions abort execution without unwinding the
                // WebAssembly/Rust stack so we need to assume the runtime is
                // FUBAR.
                runtime = undefined;
                throw e;
            }

            let outputs = [...imports.outputs];
            imports.outputs.length = 0;

            return { outputs };
        };
    }
}

export type Result = {
    outputs: OutputValue[],
};

/**
 * A tensor value generated by the SERIAL output.
 */
export type OutputValue = {
    /**
     * An integer specifying which SERIAL output this is attached to.
     */
    channel: number,
    /**
     * The tensor's dimensions.
     */
    dimensions: number[],
    /**
     * The elements in this tensor, flattened into a single array in row-major
     * order.
     */
    elements: string[] | number[],
    /**
     * The Rust name for this tensor's element type.
     */
    type_name: string,
}

class ImportsObject implements Imports {
    private decoder = new TextDecoder("utf8");
    outputs: Array<OutputValue> = [];
    private modelHandlers: Partial<Record<string, ModelConstructor>>;
    private logger: Logger;
    private capabilities: LazyCapability[] = [];

    constructor(
        modelHandlers: Partial<Record<string, ModelConstructor>>,
        logger: Logger,
    ) {
        this.modelHandlers = modelHandlers;
        this.logger = logger;
    }

    setInputs(readInput: ReadInput) {
        const inputs = this.capabilities.map(c => c.description()).map(readInput);

        for (let i = 0; i < this.capabilities.length; i++) {
            this.capabilities[i].value = inputs[i];
        }
    }

    createOutput(type: number): Output {
        const { decoder, outputs } = this;
        switch (type) {
            case Outputs.tensor:
                return tensorOutput(decoder, outputs);
            case Outputs.serial:
                return serialOutput(decoder, outputs);

            default:
                throw new Error(`Unsupported output type: ${type}`);
        }
    }

    createCapability(type: number): Capability {
        const pair = Object.entries(Capabilities).find(pair => pair[1] == type);
        if (!pair) {
            throw new Error(`Unable to handle capability number ${type}`);
        }

        const capabilityType = pair[0];
        const cap = new LazyCapability(capabilityType as CapabilityType);
        this.capabilities.push(cap);

        return cap;
    }

    createModel(mimetype: string, model: ArrayBuffer): Promise<Model> {
        const handler = this.modelHandlers[mimetype];

        if (!handler) {
            throw new Error(`No handler registered for "${mimetype}" models`);
        }

        return handler(model);
    }

    log(message: string | StructuredLogMessage): void {
        this.logger(message);
    }
}

function tensorOutput(decoder: TextDecoder, outputs: Array<OutputValue>): Output {
    return {
        consume: ({ buffer, byteLength, byteOffset }: Uint8Array) => {
            const shapeLength = new Uint32Array(buffer, byteOffset, 1)[0];
            const shapeBytes = new Uint8Array(buffer, byteOffset + 4, shapeLength);
            const shape = Shape.parse(decoder.decode(shapeBytes));
            const { type, dimensions } = shape;
            const elements = new Uint8Array(buffer, byteOffset + 4 + shapeLength, byteLength - 4 - shapeLength);
            const tensor = new Tensor(shape, elements);
            outputs.push({
                channel: -1,
                dimensions: [...dimensions],
                type_name: type,
                elements: tensorAsNumberArray(tensor),
            })
        }
    }
}

function tensorAsNumberArray(tensor: Tensor): number[] {
    const { elementType } = tensor;

    switch (elementType) {
        case "f32":
            const floats = tensor.asTypedArray(elementType);
            return Array.from(floats);
        case "u8":
            const u8s = tensor.asTypedArray(elementType);
            return Array.from(u8s);
        case "u16":
            const u16s = tensor.asTypedArray(elementType);
            return Array.from(u16s);
        case "u32":
            const u32s = tensor.asTypedArray(elementType);
            return Array.from(u32s);
        case "i8":
            const i8s = tensor.asTypedArray(elementType);
            return Array.from(i8s);
        case "i16":
            const i16s = tensor.asTypedArray(elementType);
            return Array.from(i16s);
        case "i32":
            const i32s = tensor.asTypedArray(elementType);
            return Array.from(i32s);

        default:
            throw new Error(
                `Unable to convert a ${tensor.shape.toString()} to a list of numbers`
            );
    }
}

function serialOutput(decoder: TextDecoder, outputs: Array<OutputValue>): Output {
    // We want the end user to receive all outputs as a return value, but
    // Runes are designed using a callback-based API (it's better for
    // performance). This will create an output which will stash all
    // generated values away in a list so they can be returned at the end.

    return {
        consume(data: Uint8Array) {
            const json = decoder.decode(data);
            const deserialized = JSON.parse(json);

            if (isOutputValue(deserialized)) {
                outputs.push(deserialized);
            } else if (Array.isArray(deserialized) && deserialized.every(isOutputValue)) {
                outputs.push(...deserialized);
            } else {
                throw new SerialDeserializeError(json, deserialized);
            }
        }
    }
}

function isNumberArray(value: any): value is number[] {
    return Array.isArray(value) && value.every(v => typeof v === "number");
}

function isStringArray(value: any): value is string[] {
    return Array.isArray(value) && value.every(v => typeof v === "string");
}

function isOutputValue(value?: any): value is OutputValue {
    if (!value) {
        return false;
    }

    const { channel, dimensions, elements, type_name } = value;

    return typeof channel === "number" &&
        isNumberArray(dimensions) &&
        (isNumberArray(elements) || isStringArray(elements)) &&
        typeof type_name === "string";
}

class LazyCapability implements Capability {
    type: CapabilityType;
    value?: Tensor;
    args: Record<string, number> = {};

    constructor(type: CapabilityType) {
        this.type = type;
    }

    description(): InputDescription {
        return {
            type: this.type,
            args: this.args,
        };
    }

    generate(dest: Uint8Array): void {
        if (!this.value) {
            throw new Error();
        }

        const bytes = new Uint8Array(this.value.elements);

        dest.set(bytes);
    }

    setParameter(name: string, value: number): void {
        this.args[name] = value;
    }
}

class SerialDeserializeError extends Error {
    readonly json: string;
    readonly deserialized?: any;

    constructor(json: string, deserialized: any | undefined) {
        super("Unable to deserialize the SERIAL output");
        this.json = json;
        this.deserialized = deserialized;
    }
}
